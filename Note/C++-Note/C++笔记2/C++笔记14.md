# 标准库的特殊设施

## tuple类型

- tuple类型是类似pair的模板，每个pair成员类型都不相同，每个pair恰好有两个成员，
- tuple类型的成员类型也不相同，但一个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型成员数目可以与另一个tuple类型不同
- 当我们希望将一些数据组合成为单一对象的，又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。tuple类型及其伴随类型和函数都定义在tuple头文件中
- 我们可以将tuple看作一个“快速而随意”的数据结构

- tuple支持的操作

  | tuple<T1,T2,T3,,,Tn> t;             | t是一个tuple，成员数为n，第i个成员类型为Ti。所有成员进行值初始化 |
  | ----------------------------------- | ------------------------------------------------------------ |
  | tuple<T1,T2,T3...Tn> t(v1,v2,...vn) | t是一个tuple，成员类型为T1.。。Tn，每个成员用对应的初始值vi进行初始化。此函数构造是explict的 |
  | make_tuple(v1,v2,,,vn);             | 返回一个用给定值初始化的tuple，tuple的类型从初始值的类型推断 |
  | t1  ==t2                            | 当两个tuple具有相同数量的成员且成员对应相等的时候，两个tuple相等，若其中一个不等则不用比较了 |
  | t1 != t2                            | 当两个tuple具有相同数量的成员且成员对应相等的时候，两个tuple相等，若其中一个不等则不用比较了 |
  | t1 relop t2                         | relop是关系运算符的意思，tuple的关系运算使用字典序，两个tuple必须具有相同数量的成员，使用<运算符比较t1的成员和t2中对应的成员 |
  | get<i>(t)                           | 返回t的第一个数据引用；如果t是一个左值，结果是一个左值引用，否则就是一个右值引用。tuple的所有成员都是public的 |
  | tuple_size<tupleType> ::value       | 一个类模板，可以通过一个tuple类型来初始化。他有一个名为value的public constexper static 数据成员，类型为size_t，表示给定tuple类型中成员的数量 |
  | tuple_element<i，tupleType>::type   | 一个类模板，可以通过一个整型常量和一个tuple类型来初始化。他有一个名为type的public成员，表示给定tuple类型中指定成员的类型 |

### 定义和初始化tuple

- 当我们定义一个tuple的时候，需要明确的指明类型，而且对于tuple的三个构造函数都是explict的，我们就必须使用直接初始化的手法

  ```c++
  tuple<vector<int>,vector<char>,int> b;//默认被值初始化，分别为空，空，0
  tuple<vector<int>,vector<char>,int> a({1,2,3,4,5},{'a','b'},3);//直接初始化
  tuple<vector<int>,vector<char>,int> a1{{1,2,3,4,5},{'a','b'},3};//直接初始化
  auto c=make_tuple(2,2,3);//使用make—tuple来生成对象，但是注意，这里不能像a那样写，因为这个函数不知道需要用容器存放元素
  						 //推断出来的为int，int，int
  ```

  

### 访问tuple成员，查询tuple成员

- 要访问一个tuple成员，我们会使用一个get函数

  ```c++
  auto x1=get<0>(a);//返回第一个成员
  auto x2=get<1>(a);//返回第二个成员
  get<2>(a)=2//对第三个成员赋值
  ```

- 要知道一个tuple准确类型细节信息，可以用两个辅助类模板来查询tuple成员的数量和类型

  ```c++
  size_t sz=tuple_size<c>::value;//返回3，因为有三个成员
  tuple_element<1,c>::type cnt=get<1>(c);//cnt是一个int
  ```

  

### 关系和相等运算符

- tuple的关系和相等运算符的行为类似容器的对应操作。这些运算符逐个比较左侧tuple和右侧tuple成员，只有当两个tuple
  - 类型（string等）11对应相等
  - 成员数量对应相等
  - 才能比较是否相等
- 由于tuple定义了<和==运算符，我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型

### 返回tuple的函数

- 和其他容器一样，tuple也可以作为一个返回值返回



## bitset类型

### 定义和初始化bitset

- 标准库定义了bitset类，使二进制集合处理的一些内置运算符和使用位运算变得容易

- bitset是一个类模板，它类似array类，具有固定的大小。当我们定义要给bitset时，需要声明它包含多少个二进制位

  ```c++
  bitset<32> bitvec(1U);//32位，低位为一，其他位为0
  ```

- bitset的大小必须是一个常量表达式，这条语句定义bitvec为一个包含32位的bitset。就像vector包含未命名的元素一样，bitset中二进制也是未命名的，我们通过位置来访问他们
- 二进制位的位置是从0开始编号的，因此bitvec包含编号从0到31的32个二进制位。
- 编号从0开始的二进制位被称为低位，编号到31结束的二进制位被称为高位

### 初始化bitset的方法

| bitset<n> b;                    | b有n位，每一位均为0.此构造函数是一个constexpr                |
| ------------------------------- | ------------------------------------------------------------ |
| bitset<n> b(u);                 | b是unsigned long long 值u的低n位的拷贝。如果n大于unsigned long long 的大小，则b中超出unsigned long long的高位被置为0.此构造函数是一个constexpr的 |
| bitset<n> b(s,pos,m,zero,one);  | b是string s从位置pos开始m个字符的拷贝，s只能包含字符zero和one，如果s包含任何其他字符，构造函数会抛出invaild-argument异常。字符在b中分别保存为zero和one。pos默认为-，m默认为string：：npos，zero默认为‘0’，one默认为‘1’ |
| bitset<n> b(cp,pos,m.zero,one); | 与上一个构造函数相同，但从cp指向的字符数组中拷贝字符，如果未提供m，则cp必须指向一个C风格字符串。如果提供了m，则从cp开始必须至少有m个zero或one字符 |

- 用unsigned值初始化bitset

  - 当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中二进制位将是此模式的一个副本

  - 如果bitset的大小大于一个unsigned long long 中的二进制位数，则剩余的高位被置于0.

  - 如果bitset的大小小于一个unsigned long long中的二进制位数，则只使用给定值中的低位，超出bitset大小的高位被丢弃

    ```
    bitset<13> bitvecl(0xbeef);//bitvec1比初始值小；初始值中的高位被丢弃，二进制序列为1111011101111
    bitset<20>bitvec2(0xbeef);//bitvec2比初始值大，他的高位被置于0，二进制序列为00001011111011101111
    bitset<128>bitvec3(~0ULL);//在64位机器中，long long 0ULL 是64个0比特，因此~0ULL是64个1,0-63位是1，63-127位为0
    ```

- 从一个string初始化bitset

  - 我们可以从一个string或一个字符数组指针来初始化bitset，如果string包含的祖父数比bitset少，则bitset高位被置为0

  - string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右字符）用来初始化bitset中的低位（下标为0的二进制位）。当你使用一个string初始化一个bitset时，要记住这个差别

    ```
    string str("1111111000000011001101");
    bitset<32> bitvec5(str,5,4);//从str[5]开始的四个二进制位，1100
    bitset<32> bitvec6(str,str.size()-4);//使用最后四个字符
    ```

### bitset操作

| b.any()               | b中是否存在置位的二进制位                                    |
| --------------------- | ------------------------------------------------------------ |
| b.all()               | b中所有位都置位了吗                                          |
| b.none()              | b中不存在置位的二进制位了吗                                  |
| b.count()             | b中置位的个数                                                |
| b.size()              | 一个constexpr函数，返回b中的位数                             |
| b.test(pos)           | 若pos位置是置位的，则返回true，否则返回false                 |
| b.set()               | 将位置pos处的位设置位bool值v，v默认为true，如果未传递实参，则将b中所有位置位 |
| b.set(pos,v)          | 将位置pos处的位设置位bool值v，v默认为true，如果未传递实参，则将b中所有位置位 |
| b.reset(pos)          | 将位置pos处的位复位或将b中所有位复位                         |
| b.reset()             | 将位置pos处的位复位或将b中所有位复位                         |
| b.flip()              | 改变位置pos处的位的状态或改变b中每一位的状态                 |
| b.flip(pos)           | 改变位置pos处的位的状态或改变b中每一位的状态                 |
| b[pos]                | 访问b中位置pos处的位，如果b是const的，则当该位置位时b【pos】返回一个bool值true，否则返回false |
| b.to_ulong()          | 返回一个unsigned long long 或一个unsigned long long 值，其位模式与b相同，如果b中位模式不能放入指定的结果类型，则抛出一个overflow_error异常 |
| b.to_ullong()         | 返回一个unsigned long long 或一个unsigned long long 值，其位模式与b相同，如果b中位模式不能放入指定的结果类型，则抛出一个overflow_error异常 |
| b.to_string(zero,one) | 返回一个string，表示b中的位模式，zero和one的默认值分别为0和1，用来表示b中的0和1 |
| os<<b                 | 将b中二进制位打印为字符1和0，打印到流os                      |
| is>>b                 | 从is读取字符存入b。当下一个字符不是1或0时，或是已经读入b.size()个位时，读取过程停止 |

## 随机数

- 定义在头文件ramdom中的随机数库通过一组协作的类来解决这些问题
  - 随机数引擎类：生成随机的unsigned整数序列
  - 随机数分布类：使用引擎返回服从特定概率分布的随机数

### 随机数引擎和分布

- 生成随机无符号数：`default_random_engine e;`
- 调用对象：`e()`
- 对于大多数场合，随机数引擎的输出是不能直接使用的。问题主要是生成的随机数的值的范围与我们需要的不符合，而正确转换随机数是及其困难的。

### 分布类型和引擎

- 为了得到一个分布式的数字，我们可以这样做

  ```
  uniform_int_distribution<unsigned> u(0,9);
  default_random_engine e;
  cout<<u(e)<<"endl
  ```

### 总结

- 随机数引擎：字如其名，就像是一个单独的引擎，打着了就会到处乱跑了
- 分布类型：相当于汽车/飞机，装上一个引擎u（e）就芜湖~起飞~

## IO库的补充

### 格式化输入输出

- 除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节

- 标准库定义了一组操纵符来修改流的格式

- 当使用操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效

  ```
      cout<<boolalpha<<true;//开启了流的boolalpha模式，跟在后面都会输出boolalpha模式：即true/false
      cout<<false;
      cout<<noboolalpha;//关闭了boolalpha模式
  ```

  

- 在我们使用操纵符改变状态后记得要及时恢复，不然可能会发生意想不到的错误



### 表格：定义在iostream的操纵符

| boolalpha     | 将 true 和 false 输出为字符串                                |
| ------------- | ------------------------------------------------------------ |
| ★ noboolalpha | 将 true 和 false 输出为1,0                                   |
| showbase      | 对整型值输出表示进制的前缀                                   |
| ★ noshowbase  | 不生成表示进制的前缀                                         |
| showpoint     | 对浮点值总是显示小数点 续表                                  |
| ★ noshowpoint | 只有当浮点值包含小数部分时才显示小数点 showpos 对非负数显示＋ |
| ★ noshowpos   | 对非负数不显示＋ uppercase  在十六进制值中打印0x，在科学记数法中打印 E |
| ★ nouppercase | 在十六进制值中打印 Ox ，在科学记数法中打印 e                 |
| ★ dec         | 整型值显示为十进制                                           |
| hex           | 整型值显示为十六进制                                         |
| Oct           | 整型值显示为八进制                                           |
| left          | 在值的右侧添加填充字符                                       |
| right         | 在值的左侧添加填充字符                                       |
| internal      | 在符号和值之间添加填充字符                                   |
| fixed         | 浮点值显示为定点十进制                                       |
| scientific    | 浮点值显示为科学记数法                                       |
| hexfloat      | 浮点值显示为十六进制（ C ++11新特性）                        |
| defaultfloat  | 重置浮点数格式为十进制（ C ++11新特性）                      |
| unitbuf       | 每次输出操作后都刷新缓冲区                                   |
| \* nounitbuf  | 恢复正常的缓冲区刷新方式                                     |
| ★ skipwS      | 输入运算符跳过空白符                                         |
| noskipws      | 输入运算符不跳过空白符                                       |
| flush         | 刷新 ostream 缓冲区 ends  插入空字符，然后刷新 ostream 缓冲区 |
| endl          | 插入换行，然后刷新 ostream 缓冲区                            |

*，★表示默认流状态

### 表格：定义在iomanip中的操纵符

> 定义在iomapip的操纵符大多数都是在前面读或者写多个字符的

| setfill(ch)     | 用ch填充空白            |
| --------------- | ----------------------- |
| setprecision(n) | 将浮点精度设置为n       |
| setw(w)         | 读或写值的宽度为w个字符 |
| setbase(b)      | 将整数输出为b进制       |

### 未格式化的输入输出操作

- 标准库还提供了一组底层的操作，来支持未格式化IO。这些操作允许我们将一个流当作一个无解释的字符序列来处理

- 单字节的底层IO操作

  | is.get(ch)   | 从istream is读取下一个字节存入字符ch中，返回is |
  | ------------ | ---------------------------------------------- |
  | os.put(ch)   | 将字符ch输出到ostream os，返回os               |
  | is.get()     | 将is的下一个字节作为int返回                    |
  | is.putback() | 将字节ch放回is。返回is                         |
  | is.unget()   | 将is向后移动一个字节。返回is                   |
  | is.peek      | 将下一个字节作为int返回，但是不从流中删除它    |

  - 对于标准库中三种退回字符的方法，有着细微的差别
    - peek：返回输入流中下一个字符的副本，但不会将它从流中删除，peek的返回值依然保存在流中
    - unget使得输入流向后移动，从而最后读取的值又回到流中，即使我们不知道最后从流中读取什么值，仍然可以调用unget
    - putback是更加特殊版本的unget，它退回从流中读取的最后一个值，但它接收一个参数，此参数必须与最后读取的值相同
    - 一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即标准库不保证在中间不进行读取操作的情况下使用putback或unget

- 多字节操作低层IO操作

  | is . get ( sink , size , delim )     | 从 is 中读取最多 size 个字节，并保存在字符数组中，字符数组的起始地址由 sink 给 出。读取过程直至遇到字符 delim 或读取了 size 个字节或遇到文件尾时停止。如果遇到了 delim ，则将其留在输入流中，不读取出来存入 sink |
  | ------------------------------------ | ------------------------------------------------------------ |
  | is . getline ( sink , size , delim ) | 与接受三个参数的 get 版本类似，但会读取并丢弃 delim is . read ( sink , size )读取最多 size 个字节，存入字符数组 sink 中。返回 is |
  | is . gcount ()                       | 返回上一个未格式化读取操作从 is 读取的字节数 os . write ( source , size ) 将字符数组 source 中的 size 个字节写入 os 。返回 os |
  | is . ignore ( size , delim )         | is . ignore ( size , delim ) 读取并忽略最多 size 个字符，包括 delim 。与其他未格式化函数不同， ignore 有默认参数： size 的默认值为1, delim 的默认值为文件尾 |


### 流的随机访问

> 除了cin，cout，cerr，clog，其他各种流的类型通常都支持对流中数据的随机访问。可以重定位流，使之跳过一些数据，首先读取最后一行，然后读取第一行，依次推类。标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前位置

seek和tell函数

- 为了支持随机访问，他们还提供了两个函数：
  - 一个函数通过将标记seek到一个给定位置来重定位它
  - 另一个函数tell我们标记的当前位置

表格

| tellg()/tellp()                 | 返回一个输入流中（tellg）或输出流中tellp标记的当前位置       |
| ------------------------------- | ------------------------------------------------------------ |
| seekg(pos)/seekp(pos)           | 在一个输入流或输出流中将标记重定位到给定的绝对地址。pos通常是前一个tellg或tellp返回的值 |
| seekp(off,from)/seekg(off,from) | 在一个输入流或输出流中将标记定位到from之前或之后off个字符，from可以是下列值之一<br /><br />beg：偏移量相对于流开始的位置<br /><br />cur，偏移量相对于流当前的位置<br /><br />end偏移量相对于流结尾的位置 |

> 从逻辑上讲：我们只能对istream和派生自istream类型的ifstream和istringsteam使用g版本，同样只能对ostream和派生自ostream的类型ofstream和ostringsteam使用p版本。一个iostream、fstream、stringstream既能读也能写关联的流，因此对这些类型的对象既能使用g版本又能使用p版本



只有一个标记原则

- 标准库区分seek和tell函数的“放置”和“获得”版本，但是它只是在流中维护单一的标记，并且不存在读标记/写标记
- 由于只有一个单一的标记，因此我们要在读写操作之间切换的时候，必须要进行seek操作重定位标记

# 正则表达式

## 正则表达式的简单常用语法

### [ABC]

- 作用：匹配`[...]`内部的所有的字符

- 举例

  ```c++
  [aeiou]//对于一个数据，看见aeiou就挑出来
  //原数据：an，did you used google？
  //匹配结果：a，i，o，u，u，e，o，o，e
  ```

  

### [^ABC]

- 作用：匹配除了`[...]`中字符的所有字符

- 举例

  ```c++
  [aeiou]//对于一个数据，看见aeiou就挑出来
  //原数据：an，did you used google？
  //匹配结果：n，d，d，y，s，d，g，g，l
  ```

  

### [A-Z]，[a-z]

- 作用：[A-Z]表示一个区间，匹配所有大写字母，[a-z]表示所有小写字母

- 举例

  ```
  [A-Z]//对于一个数据，看见大写的A-Z就挑出来
  //原数据：An，did you used google？
  //匹配结果：A
  [a-z]//对于一个数据，看见小写的a-Z就挑出来
  //原数据：An，did you used google？
  //匹配结果：ndidyouusedgoogle
  ```

  

### .(点)

- 作用：匹配除换行符（\n,\r)之外的任何单个字符，相当于【^\n\r】  

- 举例

  ```
  .
  ////原数据：An，did you used google？\n
  //匹配结果：An，did you used google？
  ```

  

### [\s],[\S]

- 作用：\s是匹配所有空白符，包括换行，\S非空白符，不包括换行

- 举例：

  ```
  [\s]
  ////原数据：An，did you used google？\n
  //匹配结果：    \n//几个空白和换行
  [\S]
  ////原数据：An，did you used google？\n
  //匹配结果：An，didyouusedgoogle？
  ```

  

### \w

- 作用：匹配字母，数字、下划线。等价于[A-Za-z0-9_]

- 举例

  ```
  //原数据：An，did you used google？\n
  //匹配结果：An，didyouusedgoogle？
  ```


## 正则表达式其他语法集

### 非打印字符

| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| ---- | ------------------------------------------------------------ |
| \f   | 匹配一个换页符。                                             |
| \n   | 匹配一个换行符。                                             |
| \r   | 匹配一个回车符。                                             |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。注意 Unicode 的正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。                                         |
| \t   | 匹配一个制表符。                                             |
| \v   | 匹配一个垂直制表符。等                                       |

### 特殊字符

> 当我们在匹配这些特殊字符的时候，记得加一个\

| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ---- | ------------------------------------------------------------ |
| ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *    | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .    | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {    | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|   | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

### 限定符

| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| ----- | ------------------------------------------------------------ |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

### 定位符

| ^    | 匹配输入字符串开始的位置。             |
| ---- | -------------------------------------- |
| $    | 匹配输入字符串结尾的位置。             |
| \b   | 匹配一个单词边界，即字与空格间的位置。 |
| \B   | 非单词边界匹配。                       |

## 正则表达式运算符优先级

| \                           | 转义符                                                       |
| --------------------------- | ------------------------------------------------------------ |
| (), (?:), (?=), []          | 圆括号和方括号                                               |
| *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
| ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
| \|                          | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |





## 正则表达式的用法举例（个人举例）

> - 所有的正则表达式匹配按照一行一行一般从左到右进行，对于每一个的每个字符应用正则表达式的规则查看是否适用
> - 打印字符用【】进行匹配和非打印字符直接写明\xxx,其匹配也是用\xxx
> - ，特殊字符，限定符，定位符是用来标记字符串的位置的

- 【】的匹配

  - 一个方括号对应一个字符，如果有两个方括号就匹配一组字符,匹配成功的条件是所有【】的条件均满足

    ```javascript
    var str = "12\n23\n456";
    var patt1 = /[0-9][0-9]/g;
    //匹配结果：12，23，45
    var str = "12\n23\n456";
    var patt1 = /[0-9]/g;
    //匹配结果：1，2，2，3，4，5，6
    ```

    - 如果均匹配，则显示，并且向下移动x个继续匹配，x为匹配的个数

    - 如果不匹配，则向右移动一个位置，继续匹配

      - 如果均匹配，则如上
      - 如果不匹配
        - 如果后面还有字符：继续向右移动一个位置，继续匹配
        - 如果后面没有字符/缺少字符（即能匹配的字符少于x个，x为匹配的个数）则放弃匹配

    - 举例

      ```javascript
      var str = "10\n023\n045";
      var patt1 = /[1-9][0-9]/g;
      //匹配结果：
      //		10；均匹配
      //		23：如果不匹配向右移动一个后匹配成功
      //		45：如果不匹配向右移动一个后匹配成功，在最后6没有和他组队进行匹配的，被抛弃
      ```

      

- 贪婪匹配

  - 所谓贪婪匹配，即是使用“+”和“*”进行匹配

  - 贪婪表达式都是至少执行一次或者多次d

  - 贪婪匹配的基本原理是：

    - 对于*：在匹配的时候，对于第一个括号如果符合条件的情况下，进行第二个括号匹配，

      - 匹配：绑定到一起，对于下一个字符依然用第二个【】绑定

      - 一开始就不匹配：直接输出第一个括号的，向右移动一个字符

      - 已经匹配几次后不匹配：输出绑定的，向右移动x个字符（x个字符未已经绑定的字符总量）

        ```javascript
        var str = "01\n11a023\n0456a67";
        var patt1 = /[0-1][2-9]*/g;
        //匹配结果
        	0，1，1，1：均属于一开始就第二个【】不匹配了，就只是输出第一个匹配的
            023，0456：属于一开始满足匹配条件的，从第三个往后（包括第三个匹配的是有*的条件[2-9]*
            67(未输出):属于第一个条件都不符合，无法进行第二个条件的匹配
        ```

    - 对于+：与【】类似，必须在第一个和第二个条件都满足的情况下进行匹配

      - 匹配：查看第二个，若第二个也一样则绑定到一起，对下一个字符依然用第二个【】绑定

      - 一开始就不匹配：直接向右移动一个字符继续匹配

      - 已经匹配几次后不匹配：输出绑定的，向右移动x个字符（x个字符未已经绑定的字符总量）

        ```javascript
        var str = "01\n11a023\n0456a67";
        var patt1 = /[0-1][2-9]*/g;
        //匹配结果
        	0，1，1，1（未输出）：均属于一开始第二个【】就不匹配了，
            023，0456：属于一开始满足匹配条件的，从第三个往后（包括第三个匹配的是有*的条件[2-9]*
            67(未输出):属于第一个条件都不符合，无法进行第二个条件的匹配
        ```

        

# C++——正则表达式（仅了解）

## 正则表达式的定义与组成

### 定义

- 正则表达式是一种描述字符序列的方法，是一种极其强大的计算工具

### 表格

| regex           | 表示有一个正则表达式的类                                     |
| --------------- | ------------------------------------------------------------ |
| regex_match     | 讲一个字符序列与一个正则表达式匹配                           |
| regex_search    | 寻找第一个与正则表达式匹配的子序列                           |
| regex_replace   | 使用给定格式替换一个正则表达式                               |
| sregex_iterator | 迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串 |
| smatch          | 容器类，保存在string中搜索的结果                             |
| ssub_match      | string中匹配的子表达式的结果                                 |

## 正则表达式组件的使用

```c++
string pattern("[^c]ei");
pattern="[[:alpha:]]*"+pattern+"[[:alpha":]]*"
//这里pattern的意思是，我们利用[[:alpha:]]去匹配任意字符
regex r(pattern);//构造一个用于查找模式的regex
smatch results;。。定义一个对象保存搜索结果
string text_str="receipt friend theif receive"；//用r在test——str中查找与pattern匹配的子串
if(regex_search(test_str,results,r))cout<<results.str()<<endl;//如果有匹配子串，打印匹配的单词
```

