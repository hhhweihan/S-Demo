# 重载运算符

## 重载运算符有哪些

### 可以重载的运算符

- `+,-,*,/,%,^,&,|,~,!,逗号,=,<,>,<=,>=,++,--,<<,>>,==,!=,&&,||,+=,-=,/=,%=,^=,&=,!=,*=,<<=,>>=,[],(),->,->*,new,new[],delete,delete[]`
- 这些运算符都可以重载，但是在重载的时候应该遵循其基本原理，不应该与其基本原理有不符
  - 例如，对于+，你不能重载他进行“减”的操作
- 重载函数应该成对的出现，比如有！=就有==这样

### 不可以/不建议重载的运算符

- 不可以重载的运算符
  - `::,.*,.,?:`
- 不建议重载的运算符
  - `|,&,逗号`
  - 这些运算符应该C++本身对其定义了本身的含义，如果重载就会导致原来的含义失效
    - 比如如果重载&，则会导致&&失去表示且的意思

### 一元的常见的可重载运算符

> 对于一元的重载运算符，他们往往接收一个数值，返回其对于值的引用，实际比较的时候有两个，分别是运算符左侧的对象和右侧的对象

- =
  - 我们可以重载 =运算符，其接收一个数值，返回对于值的引用
  - 我们一般把他声明为成员函数
- ！=，==
  - 我们可以重载！=，==运算符，其接收一个数值，与上面的不同，其返回一个bool类型
  - 他们一般都是成对出现进行重载，我们一般都要对这两个进行定义
  - 我们一般把他声明为成员函数
- 【】
  - 我们可以重载【】运算符，其一般接收一个数值，返回对应的引用
  - 【】运算符我们一般用来返回容器对应的值
  - 【】运算符我们一般定义两个版本，一个返回普通引用，另外一个返回常量引用

### 二元的常见的可重载运算符

> 对于二元的重载运算符，他们往往接收2个数值，返回其对于值的引用，实际比较的时候有3个，分别是运算符左侧的对象和右侧的2个对象

- +，-，*，/
  - 我们可以重载这些运算符，他们都可以接收2个数值，返回对应值的引用
  - 如果我们定义了算术运算符，我们最好也定义其复合类型
  - 一般情况下我们都把他定义在成员内部
- +=，-=，*=，/=
  - 我们可以重载这些运算符，他们都可以接收两个数值，返回对应值的引用
  - 我们要定义这些运算符，他们也必须满足对应的基本操作，即先+后=
  - 一般情况下我们把他定义在成员内部

### 特殊的可重载运算符

> 特殊的重载运算符往往和前面的不大一样，他们一般具有一些特殊的规则

- (>>)输入运算符

  - 通常情况下，输入运算符第一个参数时流的引用，第二个参数是读取的对象，返回一个流的引用
  - 在处理输入运算符的时候，我们需要处理流失败的条件，如果流失败了，我们需要对此做出判断

- （<<）输出运算符

  - 通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。第二个形参一般来说是一个常量的引用，返回一个输出的引用
  - 输出运算符应该只负责输出，而不应该同时控制格式(例如：打印换行符)
  - 输入输出运算符必须是非成员函数，对于类，我们可以把它们声明为一个友元函数

- 关系运算符<

  - 如果存在唯一一种逻辑可靠的\<定义，则应该考虑为这个类定义\<运算符。如果类同时还包括==，则当且仅当\<的定义和==产生的结果一致时才定义\<运算符，返回bool类型
  - 定义运算符时候
    - 定义顺序关系，令其与关联容器中对关键词的要求一致
    - 如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致，特别是，如果两个对象是！=的，那么一个对象应该\<另外一个

- 递增递减运算符

  - 我们在定义递增和递减运算符的时候，都需要关注一个重要的问题就是其前置和后置关系
    - 区分前置版本和后置版本的形参
      - 前置版本：`classA& operator++()`
      - 后置版本 ：`classA operator++(int)//作为额外的实参`
    - 显式的调用后置运算符
      - 如果我们需要通过函数调用的方式调用后置版本，则必须为他的整型参数传递一个值
        - `classA x                                           x.operator(0)//显式传递一个值，明确调用后置版本的operator`
  - 递增递减运算符通常应该被定义为类的成员

- 成员访问运算符，解引用运算符

  - 以上两个运算符都需要定义在成员函数中
  - 我们需要显式的调用他们
    - 以成员访问运算符为例：point.operator-\>（）

- 函数调用运算符（）

  - 函数调用运算符与其他运算符都不太一样，它可以接收任意个参数，返回一个特定的值

  - 我们一般对于定义了函数调用运算符的类就把他们当作像函数一样使用

    ```
    class B{public:int operator()(int b,int c,int d,int e){};};
    B b;
    b(2,3,4,5);
        
    ```

## 调用运算符的方法

*调用运算符的方法*

- `data1+data2`
- `operator+（data1，data2）`
- `data1.operator+=（data2）`

## 重载运算符与类

### 赋值重载运算符不能被继承

- 和构造函数一样，赋值重载运算符是不能被继承的，继承其没有意义

### 其他的重载运算符都是可以被继承的

- 因为重载运算符是特殊的函数，故除了赋值运算符，其他的运算符都是可以被继承的







# OOP

## 抽象基类

### 成员种类

- 抽象基类的成员均是有纯虚函数的，但是一般抽象基类的接口我们都定义为纯虚函数
- 和定义虚函数一样，我们在定义虚函数的后面添加“=0”，让他变为一个纯虚函数
- 注意，抽象基类是不能进行变量创建的

### 特点

- 抽象基类是不能进行变量创建的
- 因为抽象基类通常体现了本类族中各类的共性，把各类中共有的成员函数集中在抽象基类中声明。故其所有的纯虚函数在后面的派生类中都要重载

## 基类

### 成员种类

- 基本的类成员

  - 基本的数据成员（如 string s）

  - 基本的函数成员（void xxx）

  - 只属于基类自己的拷贝构造函数，移动构造函数，拷贝赋值运算符，移动赋值运算符

    - 这四个成员是只属于自己的，这个是派生类继承不了的，对于派生类，需要自己去定义

    - 但是，对于一个从基类继承而来的派生类，我们可以通过作用域进行调用

      ```C++
      class A{..};classB:public A;class C;//假设A中有operator=
      A a;
      B b;
      C c;
      
      b.operator=(2);//错误，B类中没有从A类继承operator，使用的是编译器自己合成的；
      b.A::operator=(2);//正确，使用了A的operator=，且A为B的直接基类(但是不建议这么做)
      c.A::operator=(2);//错误，C的直接基类不是A，就算是改成友元也不行
      ```

- virtual虚函数

  - 虚析构函数
    - 我们在函数中都定义虚的析构函数，方便对每一个析构函数执行不同的操作
  - 虚成员函数
    - 我们经常可以重新定义虚函数，也可以不对虚函数进行定义，如果不进行定义，则他像普通的成员函数一样会被直接继承
    - 虚函数要求传入参数的数目一样。
    - 我们在类外面声明虚成员函数的时候，不用写virtual，直接作用域+名字即可
  - 非构造函数的函数都可以是虚函数
  - virtual和override
    - 为了防止写错名字，我们前有virtual后又override，可以防止因为写错名字导致编译器认为你重新指定了一个函数

- 静态成员与静态成员函数

  - 对于静态成员
    - 无论派生类成员有多少个，静态成员永远只有一个而且是所有基类和派生类成员公用的
    - 静态成员一般需要在类外面以作用域加名称的方式进行定义
    - 静态成员类似于友元函数，他和你有关系，但是他不属于你
  - 对于静态成员函数
    - 静态成员函数一个显著特征就是在类中没有this对象，且其只能调用静态成员对象

### 特点

- 作用域
  - 作用域嵌套：
    - 对于继承的派生类，他的作用域相当于“嵌套”在基类里面，如果需要调用基类的函数，需要明显的指定
- 继承与使用
  - 继承：从直接基类继承来的，是可以直接调用的`classA a;a.operator=()。。。`
  - 使用：派生类函数有可以使用public和protect的权限，需要显式指定`class B: public classA{...}; B b;b.classA::operator=(2);`

## 派生类

### 成员函数

- 其类继承而来的成员
  - private：全继承
  - public：成员对象，成员函数，除了=以外的重载运算符，虚函数（虚成员函数，虚析构函数）
  - protect：包括成员和非成员都能访问
  - 静态成员类型
- 自己定义的成员
  - 新的普通函数
  - 重新定义的虚函数
  - 新的拷贝构造函数：递归向上调用
  - 新的移动构造函数；
  - 新的析构函数：逆向销毁，只是销毁派生类成员，后面会在调用基类析构函数进行销毁

### 特点

- 动态类型与静态类型

  - 动态类型：变量或表达式当前储存的内容

  - 静态类型：在编译一开始就可以确定的类型

  - 举例

    ```c++
    Quote *A=new xQuote;
    //假设xQuote是Quote的继承类
    //这里A的静态类型是Quote，这是在编译的时候就确定了
    //这里A的动态类型是xQuote，这是在文件运行到这里的时候，才确定的
    ```

     

- 类的”类型转换“

  - 在类中，派生类的对象可以绑定到基类的指针，但是反过来不行

  - 当基类的指针绑定到派生类上的时候，由于名字查找的限制，派生类多出的数据会被”截断“

    ```c++
    Quote A；
    xQuote B;
    Quote *p=&B；//正确，但是数据会被截断
    xQuote *q=&A；//错误，派生类不允许绑定基类
    ```

    

- 动态绑定与静态类型的名字查找：

  - 一般来说，当指针或者引用的静态类型与所绑定的对象的静态类型的不一样的时候，如果调用

    - 虚函数：就会触发动态绑定，即根据绑定的对象去调用合适版本的函数

    - 普通函数：就会触发静态类型的名字查找，即根据指针类型去寻找对应的类中是否有合适的函数，有则用，没有就报错

      ```csharp
      #include <iostream>
      class A{
      public:
          void a();
          virtual int xx(){return 3;};
      };
      class B:public A{
      public:
          void b();
          virtual int xx(){return 2;};
      };
      int main()
      {
          A x;
          B y;
          A *p=&x;//类型一致
          A *q=&y;//类型不一致
          //下面是触发静态类型的名字查找规则
          p->a();//正确，A中有a()函数
          q->b();//错误，A中没有b()函数
          //下面是触发动态绑定的时候，根据x，y来确定绑定的类型
          std::cout<<p->xx();//输出3
          std::cout<<q->xx();//输出2
      }
      ```

      

- 多态发生的条件

  -  基类中定义了虚函数 
  - 派生类中对继承自基类的虚函数进行了覆盖（重写）
  -  存在继承关系，在这种情况下，使用父类的指针或者引用调用虚函数时，这个调用可能在运行时，绑定到不同的子类中，产生不同的行为。

- 友元

  - 就像友元关系不能传递一样，友元关系同样也不能继承
  - 基类的友元在访问派生类时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员
    - 也就是说，基类的友元访问基类的的成员，派生类的友元访问自增的成员，不能访问派生类中基类的成员

  

# template



## 函数模板

### 模板形参

- 模板参数

  - 参数数量

    - 模板的参数数量是不定的，一般来说，大于等于一个

    - 参数类型有两种表示方法：typename和class，这个是对于一般的模板，他们相当于模板中可以替换的类型，他们是模板类型参数

    - 参数不能够进行重命名，如果重命名就会发生错误

      ```c++
      typedef double A;//A是double
      template <typename A,typename B> void f(A a,B,b){//这里进行了重声明，A为模板参数
      	double B;//错误，重声明模板参数B
      }
      template <typename V,typename V>//错误，两个typename不能相同
      ```

      

    - 我们还有非模板类型参数，类似于类中的静态类型，一个非类型参数可以是一个整型，或者是一个指向对象或函数类型指针或（左值）引用，其中对于整型或者函数必须满足静态对象的规则，指针或者左值引用我们必须用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参，其中指针也可以使用nullptr作为实参

  - 绑定的顺序

    - 对于绑定的顺序，一般是从左至右依次绑定，且顺序不能交换，否则会导致绑定失败需要显式指定模板实参进行绑定

      ```
      template<typename A,typename B,typename C>
      void f(A a,B b,C c)//从左至右依次绑定
      ```

  - 显式指定模板实参

    - 我们可以显式指定模板的实参，被显式指定的模板实参是可以适用于普通的类型转换，脱离限制极大的模板类型转换

      ```c++
      template<typename T> bool compare(T a,T b){return a>b;}
      long x;
      compare(x,1024);//错误，这里是匹配不上的；
      conpare<int>(x,1024)//正确，显式指定了类型，可以进行转换
      ```

    - 但是对于在函数中直接使用普通的传参的，则不受到模板类型转换的限制，但是接收普通传参的要放在最后面

      ```c++
      template<typename T> bool compare(int a,T b){return a>b;}
      long x;
      compare(x,1024);//正确，x转换为了long
      ```

  - 模板实参的类型转换

    - const忽略机制：顶层const无论是在形参中还是在实参中，都会被忽略

    - const转换机制：可以将一个非const对象的引用传递给一个const 的引用形参

    - 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换，一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针，如果函数形参是引用类型，则必须保证类型完全相同，比如对于数组，数组大小必须相同

    - 模板参数需要严格相等的机制：一个模板可以作为多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出来的类型不匹配，则调用就是错误的

      ```c++
      template<typename T> A(T,T);
      template<typename T> B(const T&,const T&);
      string s1("aaa");
      const string s2("bbb");
      int a[10],b[42]，c[10];
      long ax;
      int bx;
      A(s1,s2);//正确，使用了const忽略机制，忽略了s2的顶层const
      B(s1,s2);//正确，使用了const转换机制，将s1转换成了const string&（当然如果B是const T也是可以的
      A(a,b);//正确，使用了数组或函数的转换机制，形参非引用，可以将数组a和b转化为int*，int*进行传入
      B(a,b);//错误，对于引用机制，如果a，b数组大小不同，所以a和b数组的类型不同不符合第三条。
      B(a,c);//正确，因为a，b数组大小相同，则类型相同，可以传入a，c两个数组
      B(ax,bx);//错误，long和int的类型不同
      ```

  - 可变参数模板

    - 参数的数量也有可能是可变的。

      ```c++
      template<typename T,typename...Args>//Args是一个模板参数包，表示0或多个函数
      void foo(const T &t,const Args&...rest){//rest是一个函数参数包，表示0个或多个参数
          func(rest...)
          cout<<sizeof...rest;//我们可以使用sizeof函数知道包的大小
      }
      ```

    - 包扩展

      - 从上面可以看出，Args就是模板包扩展
      - rest就是参数包扩展
      - 扩展的一个重要的性质就是：递归调用，优先计算最底层的，然后依次向上回归

- 返回类型

  - 返回模板的形参类型

    - 单纯返回T

    - 给定作用域返回的类型

    - 对于这种类型要注意，我们需要在前面加上typename来防止其把他当作作用域来访问，显式告诉模板，这是一个名字

      ```c++
      template<typename T>
      typename T::value_type top(const T& c)//显式告知
      {
      	if(c!=empty())
      		return c.back();
      	else
      		return typename T::value_type()//告知编译器要显式返回
      }
      ```

  - 返回正常的函数类型

    - 和其他函数一样，单纯的返回一个正常类型的函数值之类的

  - 尾置返回类型

    - 对于一些与传入的模板参数有联系的，我们可以使用尾置返回类型

      ```c++
      template<typename T1>
      auto sum(T1 a,T1 b)->decltype(a)//直接可以返回
      {
      	return a;
      }
      ```

      

### 模板实例化

- 参数实例化的先后顺序
  - 和绑定的顺序类似，按照顺序从左向右依次调用

- 模板实例化后与函数重载的时候的调用规则

  - 总规则：函数优于模板，模板里针对性强的优先
    - 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例
    - 候选函数模板总是可行的，因为模板实参推断会排除任何不可行的模板
    - 对于一个调用，如果一个非函数模板和一个函数模板提供同样好的匹配，则选择非函数模板
    - 可行函数（模板与非模板）按照类型转换（如果对此调用需要的话）来排序。
    - 在定义任何函数（普通函数）之前，需要声明所有重载的函数版本
    - 如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是如果有多个同样好的匹配
      - 如果同样好的函数有一个非函数模板，则选择此非函数模板
      - 如果同样好的函数中没有非模板函数且由多个函数模板，且其中一个比其他模板更加特例化（即所接收类型转换的范围更窄），则选择此函数
      - 否则就是二义性调用

- 模板特例化和模板实例化的区别

  - 模板实例化的时间

    - 模板实例化的时间在接触到

      - 模板的声明：不实例化
      - 模板的定义：不实例化
      - 调用模板提供实参：实例化
      - 实例化模板声明：不实例化
      - 实例化模板的定义：实例化

      ```c++
      template<typename T> class A;//模板的声明
      template<typename T> class B{....}//模板的定义
      extern template A<int> ;//实例化模板的声明
      template A<int>;//实例化模板的定义
      ```

  - 模板特例化

    - 模板特例化和实例化不同，对于一个函数，模板特例化代表一个已经完整的例子，他不参与函数的匹配，但是若满足条件就一定会调用。

    - 模板特例化的前面必须有实例化的模板的声明，并且特例化中的模板参数要全部填充

      ```c++
      template <typename T> inr conpare(const T&,const T&);//先进行声明
      template <>
      int compare(const char* const &p1,const char* const &p2)//值与地址都const的了
      {
      	return strcmp(p1,p2);
      }
      ```

    - 为了特例化一个模板，原模版的声明必须在作用域中，而且在使用任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。



## 类型模板

### 模板形参

- 显式的模板实参
  - 对于类，我们同样可以定义多个模板实参，但是，模板实参需要显式的指定类型，类似于vector
- 形参数量：形参的数量不限制

- 类型成员的初始化工作

  - 对于类型成员函数，和其他普通的类一样，唯一的区别就是可以选择在template下面定义全部，或者定义部分

    - 定义全部

      ```c++
      template <typename T>class x
      {
      private:
          /* data */
      public:
          x(/* args */);
          ~x();
          void f();
          void g();
      };
      void g(){
          ;
      }
      ```

    - 定义部分

      ```
      template <typename T>class x
      {
      private:
          /* data */
      public:
          x(/* args */);
          ~x();
          void f();
          void g();
      };
      template <typename T> 
      void f(){
          ;
      }
      ```

- 类型模板别名

  - 对于一个类型模板，我们可以定义别名，且无论其是否传入模板参数

    - 对于一个已经实例化的类类型，和其他的类类型一样，我们可以用一个typedef来引用实体化的类
    - 对于一个类模板，我们可以用using定义一个类型别名

    ```++
    typedef Blob<string> xxx;//xxx为Blob<string>的别名
    template<typename T> class Pal;
    template<typename T> using aaa=Pal<T>;//aaa就是Pal模板的别名
    ```

- 类的静态成员

  - 对于一个类的静态成员，对于任意的给定模板参数X，都会有一个对应的模板A<X>,无论是公有成员还是私有成员，所有的A<X>成员都共享相同的static函数

  - 但是类模板的每个实例都有一个独有的static对象，因此与定义模板的成员函数相似，我们将static数据成员也定义为模板

  - 类似于任何而其他成员函数，一个static成员函数只有在在被使用的时候才会实例化

    ```c++
    template<typename T> class A{public:static int r;};
    template<typename T> int A<T>::r=0;//定义并初始化r
    A<int> fi,fj,fk;A<x>是一个有静态成员的类，fi，fj，fk共享同一个静态成员
    auto c=fi.r;//调用r
    ```

### 模板实例化

- 模板套模板：类模板套函数模板

  - 定义的时候

    ```c++
    template<typename T> class Blob{
    	template <typename IT> Blob(IT b,IT e);
    }
    ```

  - 声明的时候，两个函数模板都要声明

    ```c++
    template<typename T>//类的类型函数
    template <typename IT>//构造函数的类型参数
    	Blob<T>::Blob(IT b,IT e)：。。。//两个函数模板都要声明
    ```

- 类的模板特例化

  - 部分特例化

    - namespace的使用

      - 在定义特例化版本的类时候，我们必须在原模版定义所在的命名空间中特例化它

        ```c++
        namespace std{//打开命名空间
        
        }//关闭命名空间，注意，右花括号之后没有分号
        //花括号对之间的任何定义都将成为命名空间std的一部分
        ```

  - 全部特例化

    - 与函数模板不同，类模板的特例化不必为所有模板参数提供实参。
    - 我们可以只定义一部分而非所有模板函数，或是参数的一部分而非全部特性

    - 一个类模板的部分特例化本身是一个模板，使用它时，用户还必须为那些特例化版本中未指定的模板参数提供实参

    - 我们只能部分特例化类模板，而不能部分特例化函数模板  
