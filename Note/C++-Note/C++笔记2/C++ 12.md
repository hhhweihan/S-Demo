C++学习笔记12

----

# OOP：概述



## 核心思想

- OOP的核心思想是数据抽象、继承和动态绑定。
    - 使用数据抽象：将类和接口与实现分离
    - 使用继承：可以定义相似的类型并对其相似关系建模
    - 使用动态绑定：可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象



### 继承

- 通过继承联系在一起的类构成一种层次关系

  - 通常在层次关系的根部有一个基类

  - 其他类则直接或者间接的从基类继承而来，这些继承得到的类称为派生类

  - 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义了各自特有的成员

      - 基类
          - 对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数
              - `virtual (返回类型) 函数名`

      - 派生类
          - 派生类必须使用类派生列表，形式是：首先是一个冒号，后面应该紧跟以逗号分隔的基类列表,其中每个基类前面可以有访问说明符
              - `class a:public c{... //a继承了c`。且因为在a中的派生列表有public关键词，我们完全可以把a的对象当成c的对象来用
          - 派生类必须在其内部对所有重新定义的虚函数进行声明
          - 派生类可以在这样的函数之前加上virtual关键词，可以不加
          - 允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，具体方法是在该函数形参列表之后增加一个override关键词

### 动态绑定

- 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定
  - 根据传入实参的个数和类型决定运行基类函数还是派生类函数

# OOP:创建与定义



## 定义基类



### 基类与普通类的不同

- 对于基类，多了两个构造函数
  - 定义为virtual的函数
  - 定义为virtual的析构函数（虚析构函数）
- 基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

### 成员函数与继承

-  派生类可以继承其基类的成员，然而，派生类需要对这些virtual定义的操作提供自己新定义以覆盖从基类继承而来的旧定义
  - override作用：让编译器对拼写名字进行检查，确保是“重新定义”而不是因为写错函数名导致重新定义一个变量
- 基类必须将它的两种成员函数区分开来
  - 一种是基类希望其派生类进行覆盖的函数
    - 一般基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用也将被动态绑定。
    - 根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本
  - 另一种是基类希望派生类直接继承不需要改变的函数
- 虚函数相关的知识
  - 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定
  - 任何构造函数之外的非静态函数都可以是虚函数
    - 静态函数：`static int a()`
      - 静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）
  - 关键词virtual只能出现在类内部的声明语句之前而不能用类外部的函数定义
  - 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数
  - 成员函数如果没被声明为虚函数，则其解析过程发生在编译而非运行时

### 访问控制与继承

- 派生类可以继承在基类中的成员，但是派生类的成员函数一定有权访问从基类继承而来的成员
- protected：定义为派生类可以访问的成员，同时其他的用户禁止访问



## 定义派生类



### 类派生列表

- 派生类必须通过使用类派生列表明确指出它是从那个基类继承而来的
- 类派生列表的形式是
  - 首先是一个冒号，后面紧跟以逗号分隔的基类列表
  - 每个基类前面可以有以下三种访问说明符其中一个：public、protected、private

### 派生类中的虚函数

- 派生类经常（但不总是）覆盖它继承的函数。
  - 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本

### 派生类对象及派生类向基类的类型转换

- 一个派生类对象包括多个组成成分

  - 含有派生类自己定义的非静态成员对象（子类对象）
  - 一个与该派生类继承的基类对应对象，如果有多个基类，那么这样的子对象也有多个（父类对象）

- 在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续储存的

- 因为在派生类对象中含有与其基类对应的组成成分，所以我们能把派生类对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上

  - ```c++
    classA item;//基类对象
    classB item2;//派生类对象
    ClassA *p=&item;//p可以指向classA基类对象
    p=&item2;//p也可以指向classA的继承类classB的classA的部分基类对象
    ```

  - 这种转换通常称为派生类到基类的类型转换，和其他转换一样，编译器会隐式地执行派生类到基类的转换

### 派生类构造函数

- 基类使用基类的构造函数控制基类的初始化过程，派生类使用派生类的构造函数控制派生类成员的初始化
- 派生类对象和基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。
- 类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的

### 派生类使用基类的成员

- 派生类可以访问基类的共有成员和受保护成员
- 每个类负责定义各自的接口，要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此
- 派生类对象不能直接初始化其基类的成员，虽然从语法上可以但是最好不要这么做，和基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员

### 继承与静态成员

- 如果基类定义了一个静态成员，则在整个体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员只存在唯一的实例
- 静态成员遵循通用的访问控制规则，如果基类中成员是private的，则派生类无权访问，假设某静态成员是可以访问的，则我们既可以通过基类使用它也能通过派生类使用它

### 派生类的声明与被用作基类的类

- 派生类的声明

  - ```c++
    class A:B{...};//正确，这里是进行派生类的定义（派生列表）
    class A:B;//错误，派生类的列表不能出现在这里（派生列表以及与定义有关的东西必须与类的主体一起出现）
    class A;//正确，声明派生类的正确方式
    ```

- 被用作基类的类

  - 如果我们想将某个类用作基类，则该类必须以及定义而非仅仅声明

  - 一个类是基类，但是他也可以是一个派生类

    - ```c++
      class A{...};
      class A1:A{...};//A是A1的直接基类
      class A2:A1{...};//A1是A2的直接基类，同时A是A2的间接基类
      //直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来
      ```

  - 每个类都会继承其直接基类的所有成员

### 防止继承的发生

- 如果我们不希望类继承他，或者不想考虑它是否适合作为一个基类，我们可以在类名后面跟上一个final

  - ```c++
    class A final{...};
    ```





## 类型转换与继承

> 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在

### 类型的转换和绑定

- 可以将基类的指针或引用绑定到派生类对象有非常重要的一层含义：
  - 当使用基类引用或者指针的时候，实际上我们并不能清楚该引用所绑定对象的真实类型，该对象可能是引用类的对象，也可能是派生类的对象
  - 这个时候，如果调用一个visual方法的时候，即使派生类实现了该方法，也不会被调用

### 静态类型和动态类型

- 静态类型和动态类型的区别

  - 表达式为静态类型的时候，在编译的时候就是已知的，因为他是变量声明时候的类型或者表达式生成的类型

  - 动态类型则是变量或表达式表示当前内存中的内容

  - 举例

    - 静态类型在编译的时候就已经确定了，但是动态类型在运行的时候才能确定

      - ```c++
        Quote *A=new xQuote;
        //这里A的静态类型是Quote，这是在编译的时候就确定了
        //这里A的动态类型是xQuote，这是在文件运行到这里的时候，才确定的
        ```

  - 总结：

    - 如果一个变量非指针，非引用，则静态类型与动态类型一致
    - 如果一个变量时一个类的指针，或者引用，则他的静态类型和动态类型可能不一致

- 类型转换

  - 派生类向基类的自动转换只是针对指针或者引用类型有效
  - 不存在从基类向派生类的“隐式类型转换”
    - 因为这样会访问到一些未定义的对象
  - 在对象之间不存在类型转换一说

- 类与构造函数之间的关系

  - 当我们给基类的构造函数传递一个派生类对象时候，实际运行的构造函数时基类的那个，因为类只能用自己的构造函数初始化对象
  - 当我们用一个派生类对象对一个基类对象初始化或者赋值的时候，只有该派生类对象中基类部分被拷贝，移动或者赋值的时候，他的派生类部分将被忽略掉

### 关键：存在继承关系之间类型之间的转换规则

- 从派生类向基类的类型转换只针对指针或引用类型有效
- 基类向派生类不存在隐式类型转换
- 和其他成员一样，派生类向基类的类型转换也可能由于访问受限而变得不可行



## 虚函数

### 动态绑定的基本概念

- c++中，我们在使用基类的引用（指针）调用虚函数时，就会发生动态绑定。
- 所谓动态绑定，就是在运行时，虚函数会根据绑定对象的实际类型，选择调用函数的版本。
  - 如果是基类，就调用基类的，如果是派生类，就调用派生类的

### 虚函数与多态性

- 虚函数
  - 当我们使用基类的引用或者指针调用一个虚成员函数时会执行动态绑定
  - 对虚函数的调用可能在运行的时候才会被解析
  
- 多态性
  - 引用或指针的静态类型与动态类型不同这一事实正式C++语言支持多态性质的根本原因所在
  - 多态发生的条件
    - 1. 基类中定义了虚函数
      2. 派生类中对继承自基类的虚函数进行了覆盖（重写）
      3. 存在继承关系，在这种情况下，使用父类的指针或者引用调用虚函数时，这个调用可能在运行时，绑定到不同的子类中，产生不同的行为
  - 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
  
- 派生类中的虚函数
  - 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个函数时候，该函数在基类中的形参必须与派生类中的形参严格匹配
  
- final和override说明符
  - 对类/虚函数加上final/override后，编译器会代替我们检查命名操作，如果出现失误那么编译器就会及时通知我们
  - final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后
  
- 虚函数和默认实参
  - 和其他函数一样，虚函数也可以拥有默认实参，如果我们通过基类的引用或者指针调用函数，则使用基类中定义的默认实参，即使实际运行的时派生类中的函数版本也是如此
  - 如果虚函数使用默认实参，则基类和派生类的定义的默认实参最好一致
  
- 回避虚函数的机制

  - 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而实强迫其执行虚函数的某个特定版本，我们可以使用作用域运算符实现这一目的
  - 回避虚函数的情景
    - 成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制
    - 当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。
      - 在此情况下，基类版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作
      - 如果一个派生类虚函数需要调用它的基类版本，但是没有作用域运算符就会导致调用的结果无限

- 派生函数和抽象基类

  - 纯虚函数

    - 我们可以将一个虚函数定义为纯虚函数，这样做可以保证告诉用户这个操作没有实际的意义
    - 一个纯虚函数没有定义
    - 我们通过在函数体的位置（即在声明语句分号之前）书写=0就可以将一个虚函数说明为纯虚函数
      - 其中=0只能出现在类内部虚函数声明语句处
      - 值得注意的是，在某些情况下我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说我们不能为在类的内部提供一个=0的函数提供函数体

  - 抽象基类

    - 含有纯虚函数的对象是抽象基类，我们不能直接创建一个抽象基类对象

      - 抽象基类否则定义接口，而其他后续的类可以覆盖接口

      - 我们可以给抽象基类定义派生类对象，而且这些派生对象必须保证要覆盖之前抽象基类的函数；

      - ```c++
        //classA有纯虚函数，classB将覆盖A
        classA x;//错误，这里不能定义有纯虚函数的对象
        classB y;//正确，且给出了定义覆盖之前的纯虚函数
        ```

  - 初始化过程

    - ```C++
      class classA {...};//基类
      class classB : classA {...};//A是B的直接基类
      class classC : classB{
          public: 
          	classC(const string a):classB(a){}//构造函数
      }
      int main()
      {
          C("sss");//创建一个C类对象
          //此时调用classC的构造函数
          //通过函数传递将sss传递给classB
          //此时通过classB的构造函数
          //通过函数传递将sss传递给classA
          //classA的构造函数执行初始化工作，此时会初始化部分内容
          //回到classB，执行classB派生类特有元素的初始化
          //回到classC，他没有执行实际的初始化操作
          
      }
      ```

  - 重构

    - 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另外一个类中，对于面向对象的应用程序来说，重构是一种很普遍的迹象
    - 类一旦被重构，就意味着我们必须重新编译含有类的代码了






## 访问控制与继承



### 受保护的成员：protect

- 一个类使用protected关键词来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员
- protected可以说是private和public中和后的产物
  - 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
  - 和公有成员类似，受保护的成员对于派生类成员和友元来说是可以访问的
  - 派生类的成员或者友元只能通过派生类对象来访问此派生类对象中基类部分受到保护的成员，对于继承的基类对象，和其他的基类对象中的受保护成员没有任何访问权限
    - 也就是说，派生类一旦定义为对象，则其继承了基类的对象，但是不能更改原基类的对象（相当于复制了一份给自己，但是只能更改自己的复制过来的对象，但是对于被复制的对象是无权更改的。

### 公有，私有和受保护继承

- 某个类对其继承而来的成员的访问权限受到两个因素影响
  - 在基类中该成员访问说明符
  - 在派生类的派生列表中访问说明符

- 派生访问说明符
  - 派生访问说明符号（class xxx：private yyy，：后面private为访问说明符）
  - 派生访问说明符对于派生类成员能否直接访问基类成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关
    - 也就是说，在派生类的成员函数中，不管是什么继承，基类的public和protected成员依然何可访问，基类的private成员不能访问

  - 派生访问说明符的目的是控制派生类用户对于成员的访问权限
    - 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
    - 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
    - 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

  - 总结
    - 从类本身的角度来说，派生类能够访问基类的那些成员，这个是由基类决定的（相当于是没有派生访问说明符，就类本身而言）
      - 基类中定义为public和protected的成员都能被派生类访问，private不行

    - 从类的用户的角度来说，对于继承自基类的public和protected成员，派生类用户能够访问那些成员，这个由派生类访问说明符决定的
    - 注意两者的区别，一个是用户，一个是类本身，用户不能访问，但是类本身的数据确实继承且存在

- 派生类向基类转换的可访问性
  - 派生类向基类转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响，假定D继承B
    - 只要有当D共有的继承B的时候，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换
    - 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说是可访问的
    - 如果D继承B的方式是公有或者受保护的。则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用
    - 对于代码中某个给定结点来说，如果基类的公有成员是可以访问的，则派生类向基类的类型转换也是可以访问的，反之则不行


### 友元和继承

- 就像友元关系不能传递一样，友元关系同样也不能继承
- 基类的友元在访问派生类时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员
  - 也就是说，基类的友元访问基类的的成员，派生类的友元访问自增的成员，不能访问派生类中基类的成员

### 改变个别成员的可访问性

- 有时候我们需要改变派生类继承某个名字的访问级别，通过使用using声明

  - ```c++
    struct A{int x};
    class B:private A{//注意这里是private
    public:
    	using A::x//注意一般要在相对应的域对其进行声明
    }
    ```

- 通过在类内部使用using声明语句，我们可以将该类的直接或间接基类

  - 如果一条using声明语句出现在类的private部分，则该名字只能被类的成员或者友元访问
  - 如果using语句位于public部分，则类的所有用户都能访问它；
  - 如果using声明语句位于protected部分，则该名字对于成员，友元和派生类都可以访问的

- 派生类只能为那些它可以访问的名字提供using声明

### 默认的继承保护机制

- 默认情况下，使用class关键词定义的派生类是私有继承的，使用struct关键词的派生类是公有继承的
- struct和class唯一的差别就是默认访问成员说明符以及默认派生访问说明符，除此之外，再无其他不同之处
- 一个私有派生类最好显式地将private声明出来，而不要仅仅依赖于默认的设置，显式声明的好处是可以令私有继承关系清晰明了不至于产生误会



## 继承中类的作用域

每一个类都定义自己的作用域，但是存在继承关系时，派生类的作用域嵌套在其基类的作用域内

### 在编译的时候进行名字查找

- 一个对象，引用或者指针的静态类型决定了该对象的那些成员是可见的。

- 即使静态类型和动态类型可能不一致，但是我们能使用的成员依然是静态类型所决定的

- 虽然说存在着派生类到基类的“类型转换，但是查找函数的时候（使用指针访问成员）按照类的名字及其包括的成员函数去查找，对于派生类新增的是不会管的

  ```c++
  class A{
  public:
      void a();
  };
  class B:public A{
  public:
      void b();
  };
  int main()
  {
      A x;
      B y;
      A *p=&x;//类型一致
      A *q=&y;//类型不一致
      p->a();//正确，A中有a()函数
      q->b();//错误，A中没有b()函数
  }
  ```

### 名字冲突与继承

- 派生类的成员将隐藏同名的基类成员
  - 和其他作用域一样，派生类也能重用定义在其直接基类或者间接基类的名字，此时定义在内层作用域的名字将隐藏定义在外层作用域即基类的名字
- 如果像调用隐藏的成员，我们可以使用作用域运算符进行直接的调用
  - 作用域运算符将覆盖掉原有的查找规则，并指示编译器从运算符对应的类中查找
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在类内的名字
- 声明在内层作用域的函数并不会重载声明在外层作用域的函数，因此如果派生类（内层作用域）的成员与基类（外层作用域）某个成员同名，则派生类将在其作用域隐藏掉该类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也会被隐藏掉

### 名字的查找与继承

- 假定我们有p指针，p指针为一个类的指针，mem是一个函数（普通成员函数或者虚函数）
  - 首先确定p（或obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
  - 在p（或obj）的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
  - 一旦找到了mem，就进行常规的类型检查（参见6.1节，第183页）以确认对于当前找到的mem，本次调用是否合法。
  - 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：
    - 如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
    - 反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用，依据的是指针的静态类型

### 虚函数和作用域

- 我们现在可以理解为什么基类与派生类的虚函数必须拥有相同的形参列表了
  - 因为如果形参列表不相同，编译器会认为这是两个独立的同名函数，然后将基类的函数隐藏掉

### 覆盖重载的函数

- 成员函数无论是否虚函数都能被重载。派生类可以覆盖函数的0个或多个实例
- 如果派生类希望所有重载版本对于它来说都是可见的，那么它就需要覆盖所有的 版本，或者一个也不覆盖
- 一种好的方案是为重载的队员提供一条using声明语句
- 类内using声明的一般规则同样适用于重载函数的名字
- 基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。



## 构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作会发生什么样的行为

### 虚析构函数

- 我们通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本，根据传入的类型执行动态类型解析
- 和其他虚函数一样，析构函数的虚属性也会被继承，如果基类的析构函数不是虚函数，则delete一个指向 派生类对象的基类指针将产生未定义的行为
- 虚析构函数将阻止合成移动操作
- 对于派生类的析构函数，他除了销毁派生类自己的成员外，还负责调用销毁派生类直接基类的函数，该直接基类又会销毁它自己的直接基类，以此类推直至继承链的顶端

### 合成拷贝控制与继承

- 和其他合成构造函数，赋值运算符或析构函数类似，他们对类本身成员依次进行初始化，赋值或销毁的操作
- 这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值和销毁
- 值得注意的是，无论是基类成员是合成的版本还是自定义的版本都没有太大影响唯一的要求是成员要是可访问的且不是删除的函数

### 派生类中删除的拷贝控制与基类的关系

- 就像其他类一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员成被删除的函数
- 此外，某些基类的定义方式也可能导致有的派生类成员成为被删除的函数
  - 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或者析构函数被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造赋值和销毁
  - 如果基类中有一个不可访问的函数或者删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分
  - 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中对应操作时删除的或不可访问的，那么派生类中该函数将是被删除的，原因时派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的

### 移动操作与继承

- 对于基类与继承类，一旦一个类定义了自己的移动操作，那么他必须同时显式地定义拷贝操作
- 在有继承的类定义移动和继承操作，一定要提高警惕

### 派生类的拷贝控制成员

- 派生类基础函数
  - 派生类的构造函数:在初始化过程中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分
  - 派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员
  - 派生类的赋值运算符也必须为其基类部分成员赋值
  - 派生类的析构函数只是析构自己分配的资源，再调用直接基类的析构函数去西沟其他资源
  - 当派生类定义了拷贝或者移动操作时，该操作负责拷贝或移动包括基类部分在内的整个对象
- 定义派生类的拷贝和移动构造函数
  - 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分
  - 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想要拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数
- 派生类赋值运算符
  - 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类赋值
    - `a::operator=(xxx);//为派生类中的基类显式的赋值`
  - 无论是基类的构造函数或赋值运算符是自定义版本还是合成版本，派生类的对应操作都能使用他们。
    - 例如对`a::operator=(xxx)`的调用语句将执行a的拷贝赋值运算符，至于该运算符是由a显式定义的还是编译器合成的都无关紧要
- 派生类析构函数
  - 对于析构函数，对象销毁的顺序正好与其创建的顺序相反
    - 派生类析构函数首先执行，然后是基类的析构函数
    - 以此推类，沿着继承体系反方向直至最后

- 在构造函数中和析构函数中调用虚函数
  - 我们要明白，在构造和析构的过程中，上述的对象是不完整的
  - 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本
    - 也就是说，在构造函数和析构函数中调用的虚函数没有多态性，是哪个类的构造/析构，他们就会执行哪个类的虚函数，而不是动态绑定

### 继承的构造函数

- 派生类能够重用其直接基类定义的构造函数，一个只初始化它的直接基类，出于同样的原因，一个类也只能继承其直接基类的构造函数

- 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成他们

- 我们可以使用using声明让其来继承构造函数

  ```c++
  class B:public A{
      public:
      	using A::A;//使用using声明，让派生类“继承”A的构造函数
  }
  ```

  - 通常情况下，using声明语句知识令某个名字在当前作用域内可见，而当作用于构造函数时，using

    声明语句将令编译器产生代码，对于基类的每一个构造函数，编译器都生成一个与之对应的派生类构造函数

  - 这些编译器生成的构造函数形如
    `          派生类的名字（构造函数形参列表）：基类的名字（将派生类构造函数的形参传递给基类的构造函数`

    - 如果派生类含有自己的数据成员，则这些成员将被默认初始化

- 特点

  - 和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别
    - 例如不管using声明出现在那里，基类的私有构造函数在派生类中还是一个私有构造函数，受保护的构造函数和公有构造函数也是同样的规则
  - 而且，一个using声明不能指定explicit或constexpr。如果基类的构造函数explicit或者constexpr，则继承的构造函数也拥有相同的属性
  - 当一个基类构造函数含有多个默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参
  - 如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所以有这些构造函数
    - 第一个例外就是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同对的参数列表，则该构造函数将不会被继承，定义在派生类中的构造函数将替换继承而来的构造函数
    - 第二个例外就是默认的拷贝和移动构造函数不会被继承，因为这些构造函数可以安照正常的功能去合成

### 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采取间接储存的 方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型对象直接放在容器中。
  - 当派生类对象被赋值给基类对象时，其中的派生类部分会被切掉，因此容器和存在继承关系的类型无法兼容
- 当我们希望在容器中存放具有继承关系的对象的时候，我们在实际上存放的通常是基类的指针（更好的选择是只能指针）和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型

### 继承与组合

- 当我们令一个类公有的继承另外一个类的时候，派生类应当反映与基类的“是一种”的关系，在设计良好的情况的类的体系当中，公有派生类的对象应该可以用在任何需要基类的地方
- 类型之间的另一种关系是“有一个”的关系，具有这种关系的类暗含成员的意思

















​	

