C++学习笔记 11

----

# 重载运算符的基本概念

- *重载运算符是具有特殊名字的函数*
    - 关键词operator
    - 定义的运算符号
    - 返回类型
    - 参数列表
    - 函数体
- *重载运算符函数的参数数量与该运算符作用的运算对象数量一样多*
    - 一元运算符(`=,!=`)传递一个参数
    - 二元运算符（如`+，-，*，/`）传递两个参数
    - 既是一元运算符又是二元运算符：(`+ - * &`）
    - 对于一个运算符是成员函数。
        - 同时也会传this进去（等号左边的，也就是对象），因此成员运算符函数的显式参数数量比运算符的运算对象总数少一个
        - 运算符函数或者是类的成员，或者至少含有一个类类型的函数，当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义
    - 我们可以重载大多数运算符，但是我们不可以发明新的运算符
- *重载的运算符列表*
    - 可以被重载的运算符
        - `+,-,*,/,%,^,&,|,~,!,逗号,=,<,>,<=,>=,++,--,<<,>>,==,!=,&&,||,+=,-=,/=,%=,^=,&=,!=,*=,<<=,>>=,[],(),->,->*,new,new[],delete,delete[]`
    - 不能被重载的运算符
        - `::,.*,.,?:`
    - 不建议重载的运算符
        - `|,&,逗号`
        - 原因是：
            - 如果重载他们其求值的顺序不能被保存，所以即使可以重载他们但是也不应该这么做
            - C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说他们不应该被重载，否则他们的行为将异于常态，从而导致类的用户无法适应
    - 重载运算符的注意事项
        - 重载运算符应该使用与内置类型一致的含义，且尽量明智的使用运算符重载
        - 如果类执行IO操作，则定位移位运算符使其与内置类型的IO保持一致
        - 如果类的某个操作是检查相等性，则定义operator==，如果类有了operator==，意味着它通常也应该有operator！=
        - 如果类包含一个内在的单序比较操作，则定义operator\<；如果类有了operator\<，则它也应该有相对应的其他操作
        - 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容
- *调用运算符的方法*
    - `data1+data2`
    - `operator+（data1，data2）`
    - `data1.operator+=（data2）`
- *赋值和复合赋值运算符*
    - 赋值运算符
        - 赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。
        - 重载的赋值运算应该继承而非违背其内置版本的含义
    - 复合运算符
        - 如果类含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符
        - 复合运算符的行为显然应该与其内置版本一致，即先执行+，后执行=
- *选择运算符作为成员函数或者非成员函数的方法*
    - 当我们定义重载的运算符时，必须首先决定是将其声明位类的成员函数还是声明为一个普通的成员函数
    - 赋值（=），下标（【】），调用（（）），成员访问箭头（-\>）必须是成员
    - 复合赋值运算符一般来说是成员，但非必须，这样一点与赋值运算符略有不同
    - 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增，递减和解引用运算符，通常应该是成员
    - 具有对称性的运算符可能转换任意一端的运算对象，例如算术，相等性，关系和位运算符等，因此他们通常应该是普通的非成员函数
    - 如果我们想提供含有类对象的混合类型表达式，则运算符必须定义为非成员运算符
    - 当我们把运算符定义为成员函数的时候，它的左侧运算对象必须是运算符所属类的一个对象
        - 这也解释了为什么string的+的运算符左边不能是字面值，因为字面值属于const char 这样的是没有成员函数的



# 输入和输出运算符

- *重载输出运算符\<\<*
    - 通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。第二个形参一般来说是一个常量的引用，返回一个输出的引用
        - `ostream& operator<<(ostream &os,const xxx)`
    - 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符
    - 通常输出运算符应该主要负责打印的对象而非控制格式，输出运算符不应该打印换行符
    - 输入输出运算符必须是非成员函数，对于类，我们可以把它们声明为一个友元函数
- *重载输入运算符*
    - 通常情况下，输入运算符第一个形参是运算符中将要读取的流的引用，第二个形参是将要读入到的非常量对象的引用，返回一个输入的引用
    - 输入运算符必须处理可能失败的情况，当读取操作发生错误时，输入运算符应该负责从错误中恢复，而输出运算符则不需要
- *算数和关系运算符*
    - 通常情况下，我们把算数和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用，返回对应的常量
    - 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现算数运算符
- *相等运算符*
    - 如果某个类在逻辑上有相等性的含义，则该类应该定义operator==，这样就可以使用户更容易使用标准库算法来处理这个类，返回一个bool类型
    - 定义相等运算符的条件
        - 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义为operator==而不是一个普通的命名函数
        - 如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据
        - 通常情况下运算符应该有传递性
        - 如果类定义了operator==也要定义相应的operator！=
        - 相等运算符和不相等运算符中一个应该把工作委托给另外一个
- *关系运算符*
    - 如果存在唯一一种逻辑可靠的\<定义，则应该考虑为这个类定义\<运算符。如果类同时还包括==，则当且仅当\<的定义和==产生的结果一致时才定义\<运算符，返回bool类型
    - 定义运算符时候
        - 定义顺序关系，令其与关联容器中对关键词的要求一致
        - 如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致，特别是，如果两个对象是！=的，那么一个对象应该\<另外一个
- *赋值运算符*
    - 赋值运算符
        - 我们可以重载赋值运算符，不论形参的类型是什么，赋值运算符都必须定义为成员函数，他的返回类型一般是一个类的引用
    - 复合赋值运算符
        - 作为成员的二元运算符，左侧运算对象绑定到隐式的this指针
        - 赋值运算符必须定义为类的成员，复合赋值运算符通常 情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用。
- *下标运算符*
    - 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator【】
    - 下标运算符必须是成员函数
    - 如果一个类包含下标运算符，则它通常会定义两个版本，一个返回普通引用，另一个是类的常量成员并且返回常量引用
- *递增和递减运算符*
    - 我们可以为类定义递增或者递减的运算符，建议将其设定为成员函数
    - 定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义为类的成员
    - 为了与内置版本对象保持一致
        - 前置运算符应该返回递增或递减对象的引用
        - 后置运算符应该返回对象的值
    - 区分前置版本和后置版本的形参
        - 前置版本：`classA& operator++()`
        - 后置版本 ：`classA operator++(int)//作为额外的实参`
    - 显式的调用后置运算符
        - 如果我们需要通过函数调用的方式调用后置版本，则必须为他的整型参数传递一个值
            - `classA x                                           x.operator(0)//显式传递一个值，明确调用后置版本的operator`
- *成员访问运算符*
    - 在迭代器以及智能指针类常用到解引用运算符和箭头运算符，箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非如此
    - 我们可以将这两个运算符定义为const状态，因为这两个运算符不会改变对象的状态
    - 对于解引用运算符，我们一般返回一个对应类型的引用
    - 如果point是定义了operator-\>的类的一个对象，则我们使用point.operator-\>（）的结果来获取对象，重载的箭头运算符必须返回类的指针或者自定义的箭头运算符的某个类的对象
- *函数调用运算符*
    - 我们一般采用operator（）来定义函数调用运算符，如果类定义了调用u你算符，则该类的对象称作函数对象。因为可以调用这种对象，所以我们说这些对象的行为“像函数一样”
    - 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别
- *lambda也是一个函数对象*
    - 因为有函数调用运算符，所以我们可以通过类和函数调用运算符去实现lambda。
    - lambda产生的类不含有默认构造函数，赋值运算符，默认析构函数，我们可以通过手动定义构造函数然后利用operator（）向括号里面传入需要的值（相当于lambda的捕获）像函数一样的调用它(**代码块1**)

    `//代码块1`
    `//定义`
    `class sizeComp{`
    `public:`
    `sizeComp(size_t n):sz(n){}`
    `bool operator()(const string &s) const`
    `{return s.size() >= sz;}`
    `private:`
    `size_t sz;`
    `};`
    `//调用`
    `auto wc = find_if(words.begin(),words.end(),SizeComp(sz));`
    `//相当于`
    `auto wc = find_if(words.begin(),words.end(),`
    `[sz](const string &a){return a.size() >= sz;})`

- *标准库定义的函数对象*
    - 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，这些类都被定义为模板的形式，每个类分别定义了一个执行命名操作的调用运算符，与其一样返回相同类型
    - 标准库函数对象
        - 算术：`plus<type>  minus<type>  multiplies<type>           divides<type> modulus<type>  negate<type>          `
        - 关系：`equal_to<type>     not_equal_to<type>                  greater<type>      greater_equal<type>                 less<type>         less_equal<type>           `
        - 逻辑：`logical_and<type>  logical_or<type>                    logical_not<type>                             `
        - 其中type用于放入比较类型
    - 可调用对象和function
        - 标准库function类型
            - 定义在头文件functional中
            - function类型相当于函数，函数指针，lambda，函数对象类的“老大”,它可以容纳多种类型的函数，只要其可调用对象相同即可
        - function的操作
            - 操作
                - T的举例：int（int，int）（也就是调用形式）
                - `function<T> f/function<T> f(nullptr)`隐式/显式构造一个空的function函数
                - `function<T> f(obj);//在f中储存可调用对象obj的副本`
                - `f/f(arg)`将f作为条件/调用f中的对象
            - 成员类型
                - `result_type`可调用对象返回类型
                - `argument_type/first_argument_type/second_arguement_type`有1个：argument-type，两个：first，second。。
            - 调用操作：
                - `function<int(int,int)> a=[](int i,int j){return i+j}`
        - 重载函数与function
            - 对于重载函数不能直接调用function，而需要使用函数指针
            - `int add();`      `int add(int);`    `int(*p)(int,int)  这样function才能知道储存的是int指针的add `
- *重载、类型转换与运算符*
    - 类型转换运算符
        - 类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换为其他类型
        - 定义：`operator type() const{return val;}`
            - type表示类型。类型转换运算符可以面向任意类型（除了void）进行定义，只要该类型能作为函数的返回类型。因此我们不允许转换为数组或者函数，但是可以用指针类型（指向数组或者函数的指针来搞定）
        - 一个类型转换函数必须是类的成员函数；
        - 它不能声明返回类型，形参列表也必须为空
        - 类型转换函数通常为const
        - 在隐式转换的一次运算中，可以先标准内置类型隐式转换若干次，再自定义类型转换一次，反过来也可以，即自定义类型转换一次后再标准内置类型转换若干次
        - 显式的类型转换运算符
            - 为了防止反复的隐式类型转换导致的类型错误，我们引入了显式的类型转换运算符
                - `explicit operator int() const {return val}`
            - 当类型转换运算符是显式的时候，通过显式的类型转换，才能执行类型转换（**代码块2**）
            - 如果表达式被用作条件，显式的类型转换将被隐式执行
        - 转换为bool类型
            - 无论我们在什么时候在条件中使用流对象，都会使用IO类型定义的operator bool。
            - `while(std::cin>>value)`
                - cin负责将数据读入到value并且返回cin
                - 为了对条件求值，cin被istream operator bool类型隐式的执行了转换，如果cin条件是good，则函数返回为真，否则函数返回为假
                - 向bool的类型转换通常用在条件部分，因此operator bool 一般定义为explicit的
                - 向bool的类型转换通常用在条件部分，因此operator bool一般定义为explicit的

    **代码块2**
    Smallint a=3;     //正确
    a+3;//当smallint构造函数为explicit为错，因为不能隐式类型转换
    static_cast<int>(a)+3;//正确

- *避免有二义性的类型转换*
    - 如果一个类中包含一个或者多个类型转换，则必须确保在类类型呃目标类型之间只存在唯一一种转换方式，否则的话，我们编写的代码将很可能具有二义性
    - 如果类定义了一组类型转换，他们的转换源类型本身可以通过其他类型转换联系在一起，则同样会产生二义性问题
    - 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换
    - 如果确实要执行二义性的调用，就应该显式的调用构造函数或者运算符来避免隐式调用带来的问题
    - 值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也有二义性问题
    - 当我们使用两个用户定义类型转换时，如果转换函数之前或者之后存在标准类型转换，则标准类型转换将决定最佳匹配是哪个
    - 注意
        - 不要令两个执行相同的类转换
        - 避免转换目标是内置算术类型转换，特别是当你已经定义了一个转换成为算术类型的类型转换的时候
            - 不要再定义算术类型的重载运算符
            - 不要定义转换到多种算术类型的类型转换
        - 除了显式的向bool类型的转换之外，我们应当尽量避免定义转换函数并尽可能限制哪些“显然正确的构造函数”
- *函数匹配和重载运算符*
    - 和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数
    - 当我们使用重载运算符作用于类类型运算对象时候选函数中包含该运算符的普通非成员版本和成员版本。除此之外，如果左侧运算对象是类类型，则定义在类中的重载版本也在候选函数内
    - **注意**：如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符和内置运算符二义性的问题。

