## 面试问题回忆版
### 语言方面
0. 解释堆与栈之间的区别
    答：
        - 管理方式：栈由系统自动分配和释放，堆由程序员分配和释放；栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存有限；
        - 空间大小：栈在32位系统上大小为2MB，64位系统上为8MB；堆大小受限于系统的虚拟内存；栈的分配方式以进程为单位进行，分配固定的地址空间；堆的分配方式是动态的，分配的地址不固定；
        - 碎片问题：栈生长方向上向下的，向着内存地址减小的方向正长；堆的生长方向是向上的，向着内存地址增大的方向生长；栈不存在碎片问题，堆存在碎片问题；
        - 访问速度：栈机器系统提供的数据结构，计算机在底层对栈提供支持，访问速度较快；堆的数据结构一般不是直接 supported by the hardware，一般是在程序库提供的函数中实现的；
1. C++ STL的vector和list的区别
    答：
        - 底层实现与存储结构：vector底层实现为动态数组，list底层实现为双向链表；
        - 随机访问性能：vector支持随机访问，时间复杂度为O(1)，list不支持时间复杂度为O(n)；
        - 内存分配策略：vector在尾部进行插入和删除操作时，需要移动大量元素；list在头部进行插入和删除操作时，不需要移动元素；
        - 容量管理：vector的容量可以动态增加，list的容量不能动态增加；
2. C++ STL的vector如何修改扩容机制
    答：
        - 修改vector的扩容机制，需要修改vector的capacity和reserve两个函数；
        - capacity函数：返回vector的容量；
        - reserve函数：设置vector的容量；
        - 扩容机制：当vector的容量不够时，需要扩容，扩容后，将原数据拷贝到新空间中；
        - 预留空间：使用std::vector::reverse方法来预先分配足够的内存，以减少因重新分配和拷贝/移动元素而产生的开销
        ```C++
            std::vector<int> vec;
            vec.reserve(1000);  // 预留1000个元素的空间
        ```
        - 使用自定义分配器：使用自定义的分配器，可以控制内存的分配和释放；自定义分配器需要继承std::allocator，并重写allocate和deallocate方法；如内存池、对齐要求等。
        ```C++
        template<typename T>
        class MyAllocator{
            public:
            //  必要的类型定义
            T* allocate(std::size_t n)
            {
                // 分配n个元素内存
            }
            void deallocate(T* p, std::size_t n)
            {
                // 释放内存...
            }
            // 其他必要的成员函数
        }
        // 使用自定义分配器的vector
        std::vector<int, MyAllocator<int>> vec;
        ```
3. 你最熟悉的C++11特性是什么
    答：
        - 自动类型推导(auto)：允许编译器根据初始化表达式自动推断变量的类型。
        - 初始化列表：C++11允许在初始化列表中指定变量，而不是在构造函数中指定。
        - nullptr：nullptr是C++11引入的指针类型，表示空指针，具有更强的类型安全性。
        - 智能指针：C++11引入了智能指针，可以自动管理动态分配的内存。
        - Lambda表达式：可以捕获其所在作用域中的变量，并自动绑定到函数对象。
        - 右值引用（&&）和移动语义：引入右值引用和移动构造函数、赋值操作符，支持移动语义；允许资源转移时避免不必要的拷贝操作，提高性能。
        - 并发支持：引入新的内存模型，定义多线程并发环境下对共享数据的访问和修改行为；提供了std::thread、std::mutex、std::condition_variable等线程和同步原语，支持多线程编程；提供std::future、std::promise等异步编程接口。
        - 其他特性：decltype用于推导表达式的类型、static_assert在编译时进行断言检查、委托构造函数先允许一个构造函数调用同一个类中的另一个构造函数、constexpr用于定义常量表达式。
4. C++11的特性和C++14的特性有哪些
    答：
        - 标准库特性：std::optional、std::variant、std::any、std::string_view、std::filesystem等；
        - std::make_unique:类似于std::make_shared，用于创建unique_ptr；
        - 线程安全： std::shared_timed_mutex和std::shared_lock提供了对共享资源的线程安全访问控制

5. unordered_map和unordered_set的区别
6. unordered_map和map的区别，什么情况下会用map
7. 如何从map中获取你想要的元素，用什么方法
    答：
        - map：基于红黑树实现，是一种自平衡二叉搜索树。元素以键值对的形式存储，通过key可以快速查找到对应的value；
        - unordered_map：基于哈希表实现，是一种无序的关联容器。元素以键值对的形式存储，通过key可以快速查找到对应的value；
        - unordered_set：基于哈希表实现，是一种无序的集合。元素以键值对的形式存储，通过key可以快速查找到对应的value；  
8. 什么是哈希表，哈希冲突
9. 什么是虚函数，虚函数表
10. 什么是虚继承，虚继承的内存模型
11. 什么是纯虚函数，纯虚函数的作用
12. 如果在类中定义了虚函数，那么析构函数是否需要定义为虚函数
13. 什么是函数重载，函数重载的规则
14. 虚函数重载和函数重载的区别
15. 如果在派生类中定义了析构函数，那么基类的析构函数是否需要定义为虚函数，为什么
16. 基类中定义了虚析构函数，在派生类中的的析构函数是否需要定义为虚函数，为什么
17. 析构与构造的顺序
18. 什么是多态，多态的实现方式有哪些
19. 请解释引用和指针的区别，他们的应用场景有哪些
    答：
        - null值：指针可以指向nullptr或者无效地址，引用在定义时必须被初始化，且不可能引用到nullptr;
        - 重新赋值：指针可以改变指向，引用一旦初始化后就不能改变引用的目标；
        - 内存占用：指针占用单独的内存地址，引用通常不占用额外内存地址，只是变量的别名；
        - 间接访问：指针需要显式使用解引用操作符*来访问目标变量的值；引用，直接操作，就如同操作普通变量一样。
20. 如何处理内存泄漏问题，内存泄漏的分类有哪些，你如何去解决内存泄漏问题
21. 了解过智能指针吗，智能指针的原理是什么
22. shared_ptr、unique_ptr和weak_ptr的区别, 它们的使用场景有哪些
23. 什么是引用计数，引用计数的实现方式有哪些
24. 创建智能指针的几种方式，它们有什么优缺点
25. 什么是智能指针的循环引用问题，如何解决
26. 你用过python的什么数据结构，它的底层实现原理是什么
27. 你常用的数据结构有哪些，它们的特点是什么
28. 你的python是用在哪个场景，它占你工作的比重是多大

### 操作系统方面
1. 进程和线程的区别
2. 进程的几种状态
3. 讲讲你对进程的了解，进程的通讯方式
4. 多线程的几种实现方式
5. 多线程与多进程的区别
6. 你实现过多线程吗，会出现什么问题你是如何解决的
7. 锁的种类，锁的原理
8. 死锁的几种情况，如何解决
9. Linux创建文件夹的命令
10. Linux删除文件夹的命令
11. Linux文件权限的命令
12. Linux远程传输文件的命令
13. Linux查看磁盘空间的命令
14. 你用过什么调试工具，你是如何使用它的
15. 如果说你某个程序出现了中断的bug，你是如何解决的

### 设计模式方面
1. 解释一下单例模式
2. 解释一下工厂模式
3. 解释一下代理模式
4. 解释一下解释器模式
5. 讲一下你对单例模式的理解，单例模式有哪些
6. 单例模式的实现方式，有什么优点和缺点
7. 单例模式的应用场景有哪些
8. 讲一下你对设计模式的理解